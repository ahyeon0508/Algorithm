# 피로도

-----
### 🌞 문제
하루에 한 시간 단위로 일을 하거나 일을 쉬어도 된다. 하루에 한 시간 일하면 피로도는 A 만큼 쌓이고 일은 B 만큼 처리할 수 있다.

만약에 한 시간을 쉰다면 피로도는 C 만큼 줄어든다. 단, 피로도가 음수로 내려가면 0으로 바뀐다. 당연히 일을 하지 않고 쉬었기 때문에 처리한 일은 없다.

피로도를 최대한 M 을 넘지 않게 일을 하려고 한다. M 를 넘기면 일하는데 번아웃이 와서 이미 했던 일들도 다 던져버리고 일을 그만두게 된다.

번아웃이 되지 않도록 일을 할때 하루에 최대 얼마나 일을 할 수 있는지 구해보자. 하루는 24시간이다.
   
### 📝 입력
첫 번째 줄에 네 정수 A, B, C, M이 공백으로 구분되어 주어진다.

맨 처음 피로도는 0이다.

### 👋 출력 
하루에 번 아웃이 되지 않도록 일을 할 때 최대 얼마나 많은 일을 할 수 있는지 출력한다.

### 🚩 입출력 예제
- 입력  
5 3 2 10  
  
- 출력  
24  
  
### 👩‍💻 풀이
```python
a, b, c, m = map(int, input().split())
health = 0
hour = 0
work = 0

while hour != 24:
    # 일했을 때 피로도가 m보다 크면 반복문 종료
    if a > m:
        break

    if health + a <= m:
        health += a
        work += b
    else:
        health -= c
        # 피로도가 음수로 내려가면 0
        if health < 0:
            health = 0

    hour += 1

print(work)
```

### 🔑 구현 아이디어
- 일했을 때 피로도(a)가 m보다 큰 경우 반복문을 종료해주는 조건을 넣는다.
- 현재 피로도 + a가 m보다 작거나 같은 경우에 일을 한다.
- 아닌 경우 쉬면서 피로도를 빼준다.
- 피로도가 음수로 내려갈 경우를 대비하여 if문을 통해 0으로 세팅해준다.
  
### 🙋‍♀‍ 문제에 대한 나의 생각
- 테스트 케이스를 통과했지만 답이 계속 틀려서 다시 풀었다.
- 알고보니 현재 피로도 + a로 했어야는데 현재 피로도만 가지고 조건문을 세팅해두어 틀렸다.
- 그래도 디버깅을 하면서 찾아내서 다행이다!

-------------
#### 📚 출처
- [백준 22864](https://www.acmicpc.net/problem/22864)
#### 📅 공부 날짜 및 소요 시간
- ⭕ 2022.02.02 (생각 및 구현 : 20분)  
#### ⭐ 개인적인 난이도 : 0.3 / 5