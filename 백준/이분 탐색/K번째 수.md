# K번째 수

-----
### 🌞 문제
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.
   
### 📝 입력
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.

### 👋 출력 
B[k]를 출력한다.

### 🚩 입출력 예제
- 입력  
3  
7     
  
- 출력  
6
  
### 👩‍💻 풀이
```python
n = int(input())
k = int(input())

start = 1
end = k

while start <= end:
    mid = (start + end) // 2

    cnt = 0
    for i in range(1, n+1):
        cnt += min(mid // i, n)

    if cnt >= k:
        answer = mid
        end = mid - 1
    else:
        start = mid + 1
        
print(answer)
```

### 🔑 구현 아이디어
- 각 행은 구구단처럼 나타나기에 (a/행번호)가 그 행에서 구하고자 하는 개수이다.  
  (단, (a/행번호)가 N보다 클 경우에는 N이다 => <b>min()함수를 쓴 이유</b>)
- mid(k)보다 작거나 같은 숫자들을 전부 찾아줌으로써 mid(k)가 몇번째에 위치하는 숫자인지 알아낸다.

### 🙋‍♀‍ 문제에 대한 나의 생각
- 오랜만에 이분 탐색 문제를 접근해봐서 그런가 너무 어려웠다ㅠㅠ
- 문제 자체도 이해를 하지 못 해 답을 봐도 머리가 아팠다😯 우선 어찌저찌 이해함..

-------------
#### 📚 출처
- [백준 1300](https://www.acmicpc.net/problem/1300)
- [참고](https://codingsmu.tistory.com/79)
#### 📅 공부 날짜 및 소요 시간
- ❌ 2022.01.06 (생각 및 구현 : 5분 -> 답 보고 이해 40분)  
#### ⭐ 개인적인 난이도 : 4 / 5