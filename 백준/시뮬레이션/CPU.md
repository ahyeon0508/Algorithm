# CPU

-----
### 🌞 문제
디지털하드웨어설계 과목의 최종 프로젝트는 16-bit CPU를 설계하고 Verilog 언어로 구현하는 것이다. 본인이 구현한 CPU가 제대로 동작하는지 테스트하기 위해서는 기계어 코드를 입력으로 주어야 한다. 하지만 대부분의 사람은 0과 1로만 이루어진 기계어 코드를 이해하기 힘들어서 C++, Java와 같은 프로그래밍 언어로 코드를 작성하고 컴파일러를 통해 기계어 코드로 번역하는 과정을 거친다.

여러 가지 프로그래밍 언어 중에서 어셈블리어는 사람이 이해하기 쉬우면서 기계어와 가장 유사한 언어이다. 어셈블리어 코드는 어셈블러를 통해 기계어 코드로 번역된다. 그리고 어셈블리어는 기계어와 일대일로 대응하는 특징이 있다. 예를 들면, 두 수의 합을 구하는 연산의 어셈블리어 코드가 ADD이고, 기계어 코드가 00000이면 어셈블러는 ADD를 읽어서 그대로 00000로 바꾸어주는 것이다.

아래의 그림은 민호가 설계한 CPU가 처리할 수 있는 16-bit 단위 명령어들의 구조를 모아놓은 표이다.
![표](https://user-images.githubusercontent.com/44939208/147424791-567fab58-b08d-4940-8b6b-533f72649c7a.jpeg)

입력과 출력은 항상 명령어 단위이며, 어셈블리어 코드는 "opcode rD rA rB" 또는 "opcode rD rA #C"의 형태이다. 기본적으로 레지스터 rA와 rB에 있는 두 수 또는 레지스터 rA에 있는 수와 상수 #C를 opcode에 해당하는 연산을 수행하고, 그 결괏값을 레지스터 rD에 저장하는 명령어이다. rA는 opcode에 따라 사용하지 않을 수도 있다. 어셈블러는 opcode, rD, rA, rB, #C를 각 bit의 자리에 맞게 2진수 0과 1로 이루어진 16-bit 기계어 코드로 변역한다. bit마다 자리의 의미는 아래와 같다.

- 0~4 : CPU가 수행해야 할 연산을 나타내는 opcode이다. 만약 4번 bit가 0일 경우 레지스터 rB를, 1일 경우 상수 #C를 사용한다.
- 5 : 사용하지 않는 bit이며, 항상 0이다.
- 6~8 : 결괏값을 저장하는 레지스터 rD의 번호이다.
- 9~11 : 연산에 사용되는 레지스터 rA의 번호이다. 사용하지 않을 경우에는 000이다.
- 12-15 : 만약 4번 bit가 0일 경우 12-14번 bit는 연산에 사용되는 레지스터 rB의 번호이며, 15번 bit는 항상 0이다. 만약 4번 bit가 1일 경우 12~15번 bit는 상수 #C이다.

디지털하드웨어설계 과목을 듣는 민호는 Verilog로 16-bit CPU 구현을 일찍 끝내 놓은 상태이다. 이 16-bit CPU를 테스트하기 위해서는 기계어를 매번 입력으로 줘야 하는데, 너무나 귀찮은 민호는 이에 맞는 어셈블러를 구현하려고 한다. 민호가 직접 설계한 16-bit CPU의 명령어 구조 표를 보고, 어셈블리어 코드가 주어졌을 때 이를 기계어 코드로 번역하는 어셈블러를 만들어보자.

### 📝 입력
첫 번째 줄에는 명령어의 개수를 의미하는 정수 N (1 ≤ N ≤ 500)이 주어진다.

다음 N개의 각 줄에는 명령어가 어셈블리어 코드로 "opcode rD rA rB" 또는 "opcode rD rA #C"의 형태로 주어진다. 문자열 opcode는 항상 대문자이다. 정수 rD, rA, rB (0 ≤ rD, rA, rB ≤ 7)는 레지스터 번호를 의미한다. 사용하는 레지스터 번호는 1부터 7까지이며, 사용하지 않을 경우에만 0이 주어진다. 정수 #C (0 ≤ #C ≤ 15)는 상수를 의미한다.

기계어 코드로 번역될 때 어긋나는 입력은 주어지지 않는다.

### 👋 출력 
N개의 각 줄에 어셈블리어 코드를 기계어 코드로 번역하여 출력한다.

### 🚩 입출력 예제
- 입력  
4   
MOVC 1 0 5   
MOVC 2 0 10  
ADD 3 1 2  
SUB 4 1 2   
  
- 출력  
0010100010000101  
0010100100001010  
0000000110010100  
0001001000010100  
  
### 👩‍💻 풀이
```python
n = int(input())

opcode = {
    'ADD' : '0000','SUB' : '0001',
    'MOV' : '0010','AND' : '0011',
    'OR' : '0100','NOT' : '0101',
    'MULT' : '0110','LSFTL' : '0111',
    'LSFTR' : '1000','ASFTR' : '1001',
    'RL' : '1010','RR' : '1011'
}

for i in range(n):
    answer = ''
    assemble = input().split()
    # 0~4
    if assemble[0][-1] == 'C':
        answer += opcode[assemble[0][:-1]] + '1'
    else:
        answer += opcode[assemble[0]] + '0'
    # 5
    answer += '0'
    # 6~8
    rD_temp = ''
    rD = int(assemble[1])
    while rD != 0:
        rD_temp += str(rD % 2)
        rD //= 2
    rD_temp = rD_temp[::-1]
    answer += rD_temp.rjust(3, "0")
    # 9~11
    rA_temp = ''
    rA = int(assemble[2])
    while rA != 0:
        rA_temp += str(rA % 2)
        rA //= 2
    rA_temp = rA_temp[::-1]
    answer += rA_temp.rjust(3, "0")
    # 12~15
    rB_temp = ''
    rB = int(assemble[3])
    if answer[4] == '0':
        while rB != 0:
            rB_temp += str(rB % 2)
            rB //= 2
        rB_temp = rB_temp[::-1]
        answer += rB_temp.rjust(3, "0") + "0"
    else:
        while rB != 0:
            rB_temp += str(rB % 2)
            rB //= 2
        rB_temp = rB_temp[::-1]
        answer += rB_temp.rjust(4, "0")

    print(answer)
```

### 🔑 구현 아이디어
- 차근차근 해보면 된다!
  
### 🙋‍♀ 문제에 대한 나의 생각
- rjust(), ljust(), zfill()에 대해 다시 공부해볼 수 있었던 문제였다.
```python
print("1".rjust(3, "0")) # 001
print("1".ljust(3, "0")) # 100
print("1".zfill(3)) # 001 : zfill()은 0을 왼쪽에 채워줌
```

-------------
#### 📚 출처
- [백준 16506](https://www.acmicpc.net/problem/16506)
#### 📅 공부 날짜 및 소요 시간
- ⭕ 2021.12.27 (생각 및 구현 : 30분)  
#### ⭐ 개인적인 난이도 : 0.2 / 5